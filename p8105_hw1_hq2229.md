p8105_hw1_hq2229
================
Hantang Qin
2025-09-17

Part1.

``` r
library(moderndive)
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ─────────────
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.2     ✔ tibble    3.3.0
    ## ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
    ## ✔ purrr     1.1.0     
    ## ── Conflicts ──────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
data("early_january_weather")
n_rows <- nrow(early_january_weather)
n_cols <- ncol(early_january_weather)
mean_temp <- mean(early_january_weather$temp, na.rm = TRUE)
```

This dataset has 358 rows and 15 columns,  
so it’s pretty big but still easy to explore. The average temperature
works out to  
about 39.6 °F, which gives me a quick sense  
of how chilly it was in early January. The most important columns are
`time_hour`  
(the actual time stamps), `temp` for temperature, and `humid` for
humidity — these are what  
I’ll focus on to see how weather changes over time.

``` r
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point() +
  labs(title = "Temperature vs Time in Early January",
       x = "Time", y = "Temperature (°F)", color = "Humidity")
```

![](p8105_hw1_hq2229_files/figure-gfm/unnamed-chunk-2-1.png)<!-- -->

``` r
ggsave("scatter_temp_time.png")
```

    ## Saving 7 x 5 in image

**Interpretation.** The temperature data shows a clear daily (diurnal)
cycle—cooler at night and warmer during the day. Higher humidity
(lighter points) tends to align with the cooler nighttime and
early-morning periods, while humidity stays relatively steady when
temperatures peak around January 14–15.

Part2

``` r
library(tidyverse)

set.seed(123)  

random_sample <- rnorm(10)                     
logical_vec   <- random_sample > 0           
char_vec      <- letters[1:10]                 
factor_vec    <- factor(rep(c("low","med","high"), length.out = 10))  

mixed_type_df <- tibble(
  random_sample = random_sample,
  logical_vec   = logical_vec,
  char_vec      = char_vec,
  factor_vec    = factor_vec
)

mixed_type_df
```

    ## # A tibble: 10 × 4
    ##    random_sample logical_vec char_vec factor_vec
    ##            <dbl> <lgl>       <chr>    <fct>     
    ##  1       -0.560  FALSE       a        low       
    ##  2       -0.230  FALSE       b        med       
    ##  3        1.56   TRUE        c        high      
    ##  4        0.0705 TRUE        d        low       
    ##  5        0.129  TRUE        e        med       
    ##  6        1.72   TRUE        f        high      
    ##  7        0.461  TRUE        g        low       
    ##  8       -1.27   FALSE       h        med       
    ##  9       -0.687  FALSE       i        high      
    ## 10       -0.446  FALSE       j        low

``` r
vars <- c("random_sample", "logical_vec", "char_vec", "factor_vec")

mean_results <- tibble(
  variable = vars,
  attempt  = map(vars, ~ tryCatch(
    mean(pull(mixed_type_df, .x)), 
    error = function(e) paste("ERROR:", e$message)
  ))
)
```

    ## Warning in mean.default(pull(mixed_type_df, .x)):
    ## 参数不是数值也不是逻辑值：返回NA
    ## Warning in mean.default(pull(mixed_type_df, .x)):
    ## 参数不是数值也不是逻辑值：返回NA

``` r
mean_results
```

    ## # A tibble: 4 × 2
    ##   variable      attempt  
    ##   <chr>         <list>   
    ## 1 random_sample <dbl [1]>
    ## 2 logical_vec   <dbl [1]>
    ## 3 char_vec      <dbl [1]>
    ## 4 factor_vec    <dbl [1]>

``` r
logical_as_num <- as.numeric(mixed_type_df$logical_vec)  
char_as_num    <- as.numeric(mixed_type_df$char_vec)    
```

    ## Warning: 强制改变过程中产生了NA

``` r
factor_as_num  <- as.numeric(mixed_type_df$factor_vec)  

mean_logical_num <- mean(logical_as_num)
mean_char_num    <- mean(char_as_num, na.rm = TRUE)  
mean_factor_num  <- mean(factor_as_num)
```

The mean works for random_sample because it’s numeric, and for
logical_vec because TRUE/FALSE are treated as 1/0. It fails for char_vec
and factor_vec since those aren’t numeric by default. After using
as.numeric(), logicals become 0/1, characters become NA (with a
warning), and factors convert to their underlying level codes (low=1,
med=2, high=3). This explains the “what works and why” behavior for the
mean.
